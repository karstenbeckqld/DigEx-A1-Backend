// User Routes

const express = require('express');
const router = express.Router();
const User = require('../models/user');

// Handle errors for user signup
// The handleErrors function reads the errors generated by the user model or mongoose and allows for them to be returned
// to the user in json format.
// Error handling function derived from Net Ninja Tutorial Node.js Auth Tutorial (JWT),
// https://www.youtube.com/playlist?list=PL4cUxeGkcC9iqqESP8335DA5cRFp8loyp
const handleErrors = (err) => {

    let errors = {email: '', password: ''};

    // Duplicate email error
    // The user model defines for email addresses to be unique. As they get used as login, this makes sense. If a user
    // tries to register with an email that is already present in the database, mongoose will throw an error. Here we
    // catch the error code produced by mongoose to relay a message to the front end in json format, so that the user
    // gets informed that the entered email is already registered.
    if (err.code === 11000) {
        errors.email = 'This email is already registered';

        return errors;
    }

    // Input validation errors
    // We've put other requirements in the user model, ie. that an email must be provided upon registration and that the
    // password must have a certain length. These validations get returned by mongoose with the prefix: User validation
    // failed. All these kinds of errors will be handled by the below code block and are returned to the user in a more
    // user-friendly way.
    // Mongoose returns an error object with values for each error that occurred. With err.errors, we access this errors
    // object and with forEach(({properties})) we can cycle through the contained properties. The line with
    // errors[properties.path] = properties.message assigns these property values to the locally defined errors properties
    // email and password, respectively. In the end, the code returns these values to the user route.
    if (err.message.includes('User validation failed')) {
        Object.values(err.errors).forEach(({properties}) => {
            errors[properties.path] = properties.message;
        });

        return errors;
    }
};

// As database operations are not carried out on the same server, there might be a slight delay between the request and
// the response. Therefore, we carry out database operations in an asynchronous way. This is why all the following code
// blocks use async and await for operations on the database.

// GET - Get all users -------------------------------------------------------------------------------------------------
// Endpoint: /user
// The get method gets all users from the database with the find() method on the User object. It then returns the users
// from the database as a json object. In case of an error, we return a 400 status code and a json object containing a
// custom message plus the error message from mongoose.
router.get('/', async (req, res) => {
    await User.find()
        .then((users) => {
            res.status(200).json(users);

            // For A3
            // res.render('user/index', { users: result });
        })
        .catch((err) => {
            console.log('Cannot get list of users: ', err);
            res.status(400).json({
                message: 'Cannot get users.',
                error: err
            });

            // For A3
            // res.redirect('/');
        });
});

// GET - Get specific user by id ---------------------------------------------------------------------------------------
// Endpoint: /user/:id
// The below get method looks up a user by a specified ID (/:id route). It uses the mongoose findById() method that
// takes in the database id as parameter. We receive this parameter by using the req.params.id property, which we receive
// from the request. If no user with this id exists, we return a 404 status code (not found) and a json message. If the
// user exists, we return the user object. If there is an error with the request we handle it in the same way as above.
router.get('/:id', async (req, res) => {
    await User.findById(req.params.id)
        .then((user) => {
            if (!user) {
                res.status(404).json({
                    message: 'User does not exist.',
                });
            } else {
                console.log('User Found');
                res.json(user);
            }
        })
        .catch((err) => {
            console.log('User not found: ', err);
            res.status(400).json({
                message: 'Cannot find user.',
                error: err
            });

            // For A3
            // res.redirect('/');
        });
});

// GET - Show Form to input new user -----------------------------------------------------------------------------------
// Endpoint: /user/new
// To add a new user to the database, we first use a get request to display an input form, so that a user can register.
// For the front end to be able to add input data to the database, we pass along a new User object, which gets populated
// with the inputs from the form. This form then returns a post request which gets handled in the next code block.
router.get('/new', (req, res) => {
    res.render('user/newUser', {user: new User()});
});

// POST - Receive Form Data from GET('/new') ---------------------------------------------------------------------------
// Endpoint: /user
// The below post request receives data from the input form and creates a new user.
router.post('/', async (req, res) => {

    // Check if the request body is empty and if yes, return here.
    if (!req.body) {
        return res.status(400).json({
            message: "Empty body received."
        });
    }

    // Setup new User object with data from request body. We define an object and populate its properties from the
    // request body.
    const {firstName, lastName, email, accessLevel, password, bio} = req.body;

    // Create new User object by using the properties from above.
    const user = new User({
        firstName,
        lastName,
        email,
        accessLevel,
        password,
        bio,
    });

    // Save the new user to the database
    // Now we save the new user to the database with the save() method. If the user gets saved successfully, we return
    // the user object as json data and set the status to 201.
    await user.save()
        .then((user) => {
            console.log('New user created.');
            res.status(201).json(user);
        })
        .catch((err) => {
            // Because the User object defines the email to be unique, mongoose will check for this property and throw an
            // error, if the entered email already is in the database. This will get caught here and the user returned to
            // the New User dialog with an error message. Here we also check for the right password length and add this
            // error to the return if it occurs.
            console.log('User not created.');
            const errors = handleErrors(err);
            res.status(500).json({errors});


            // For A3
            // res.render('user/newUser', {
            //    user: user,
            //    errorMessage: err,
            // });
        });
});

// PUT - Update user with id -------------------------------------------------------------------------------------------
// Endpoint: /user/:id
// To update a user, we use a put request as these are usually used for updating database entries.
router.put('/:id', async (req, res) => {

    // Check if the request body is empty and if yes, return here (same as above).
    if (!req.body) {
        return res.status(400).json({
            message: "Empty body received."
        });
    }

    // Update the user model
    // The findByIdAndUpdate() method allows us to find and update a user in one go. For this, we read the passed on id
    // from the request (/:id) and the body from the request. Then we return the update user as json in the response. If
    // an error occurs, we add it to the response. We also use the handleErrors function here as the user might have
    // wanted to update their email or password and this function specifically handles these errors. As many things can
    // go wrong, we also pass on the error itself.
    await User.findByIdAndUpdate(req.params.id, req.body, {new: true})
        .then((user) => {
            res.json(user);
        })
        .catch((err) => {
            console.log('User not updated.', err);
            const errors = handleErrors(err);
            res.status(500).json({
                message: 'User not updated.',
                errors: errors,
                error: err
            });
        });
});

// DELETE - Delete user with id ----------------------------------------------------------------------------------------
// Endpoint: /user/:id
// To delete a user, we use a delete request as these are often used for database entry deletion.
router.delete('/:id', async (req, res) => {

    // Check id ID is missing from the request, if yes, return.
    if (!req.params.id) {
        return res.status(400).json({
            message: 'User ID missing from request'
        });
    }

    // Delete the user with Id from request
    // To delete a user, we utilise the findOneAndDelete() method from mongoose that takes in a property for lookup.
    // Technically, we could use more than one property with this method, but the id is sufficient in our case. If the
    // id is found and deleted, we add a message to the response. If an error occurred, we return a status of 500 and
    // add the error plus a custom message to the returned json object.
    await User.findOneAndDelete({_id: req.params.id})
        .then(() => {
            res.json({
                message: `User with ID: ${req.params.id} deleted.`
            });
        })
        .catch((err) => {
            console.log('User not deleted.', err);
            res.status(500).json({
                message: 'User not deleted.',
                error: err
            });
        });
});

module.exports = router;
